# Copyright lowRISC contributors.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

"""Part of the fault injection framework for the OpenTitan.

This template consists of several template string functions to autogenerate the
cell library.

"""

cell_header = """
# Copyright lowRISC contributors.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

import logging

import networkx as nx
from sympy import Symbol, false, true

'''Part of the fault injection framework for the OpenTitan.

*** Autogenerated with the cell_lib_generator.***

This library provides the mapping for a gate type of the Nangate45 library to a
boolean formula in CNF.
'''
logger = logging.getLogger(__name__)

# Set the clock and reset name and values.
clk_name = 'clk_i'
clk_value = true

rst_name = 'rst_ni'
rst_value = false

registers = {'DFFS_X1', 'DFFR_X1'}
"""

cell_in_validation = """
def validate_inputs(inputs: dict, graph: nx.DiGraph, type: str) -> dict:
    ''' Validates the provided input of the gate.

    This function verifies that all inputs are present for the selected gate.

    Args:
        inputs: The list of provided inputs.
        graph: The networkx graph of the circuit.
        type: The type of the gate.

    Returns:
        The inputs for the gate.
    '''
    type_extracted = type.rsplit('_', 1)[0]
    type_pins = gate_in_type[type_extracted]
    expected_inputs = in_type_pins[type_pins]

    if expected_inputs <= inputs.keys():
        input_symbols = {}
        for input_pin, input in inputs.items():
            if graph.nodes[input.node][
                    'node'].type == 'input' and clk_name in input.node:
                input_symbols[input_pin] = clk_value
            elif graph.nodes[input.node][
                    'node'].type == 'input' and rst_name in input.node:
                input_symbols[input_pin] = rst_value
            elif graph.nodes[input.node]['node'].type == 'null_node':
                input_symbols[input_pin] = false
            elif graph.nodes[input.node]['node'].type == 'one_node':
                input_symbols[input_pin] = true
            else:
                input_symbols[input_pin] = Symbol(input.node + '_' +
                                                  input.out_pin)

        return input_symbols
    else:
        logger.error(inputs)
        raise Exception(f'Gate {{type}} is missing some inputs.')
"""

otfi_cells = """
# OTFI specific cells.
def xnor(inputs: dict, graph: nx.DiGraph) -> Symbol:
    ''' xnor gate.

    Args:
        inputs: {'I1', 'I2', 'node_name'}.
        graph: The networkx graph of the circuit.

    Returns:
        ZN = '!(I1 ^ I2)'.
    '''
    p = validate_inputs(inputs, graph, 'xnor')

    return ((~p['I1'] | ~p['I2'] | p['node_name']) &
            (p['I1'] | p['I2'] | p['node_name']) &
            (p['I1'] | ~p['I2'] | ~p['node_name']) &
            (~p['I1'] | p['I2'] | ~p['node_name']))


def xor(inputs: dict, graph: nx.DiGraph) -> Symbol:
    ''' xor gate.

    Args:
        inputs: {'I1', 'I2', 'node_name'}.
        graph: The networkx graph of the circuit.

    Returns:
        ZN = '(I1 ^ I2)'.
    '''
    p = validate_inputs(inputs, graph, 'xor')

    return ((~p['I1'] | ~p['I2'] | ~p['node_name']) &
            (p['I1'] | p['I2'] | ~p['node_name']) &
            (p['I1'] | ~p['I2'] | p['node_name']) &
            (~p['I1'] | p['I2'] | p['node_name']))


def and_output(inputs: dict, graph: nx.DiGraph) -> Symbol:
    ''' and gate.

    AND gate for the output logic. As this is the last element of the formula
    the expression '& node_name' is added.

    Args:
        inputs: {'A1', ..., 'AN', 'node_name'}.
        graph: The networkx graph of the circuit.

    Returns:
        ZN = 'A1 & ... & AN' & node_name.
    '''
    if len(inputs) == 3:
        return AND2_X1(inputs, graph) & Symbol(inputs['node_name'].node + '_' +
                                               inputs['node_name'].out_pin)
    elif len(inputs) == 4:
        return AND3_X1(inputs, graph) & Symbol(inputs['node_name'].node + '_' +
                                               inputs['node_name'].out_pin)
    elif len(inputs) == 5:
        return AND4_X1(inputs, graph) & Symbol(inputs['node_name'].node + '_' +
                                               inputs['node_name'].out_pin)
    elif len(inputs) == 6:
        return AND5_X1(inputs, graph) & Symbol(inputs['node_name'].node + '_' +
                                               inputs['node_name'].out_pin)
    elif len(inputs) == 7:
        return AND6_X1(inputs, graph) & Symbol(inputs['node_name'].node + '_' +
                                               inputs['node_name'].out_pin)
    else:
        raise Exception('Missing and gate for output logic.')


def input_formula(inputs: dict, graph: nx.DiGraph) -> Symbol:
    ''' Sets a input pin to a predefined (0 or 1) value.

    Args:
        inputs: {'I1', 'node_name'}.
        graph: The networkx graph of the circuit.

    Returns:
        0 or 1.
    '''

    p = validate_inputs(inputs, graph, 'input_formula')
    if inputs['node_name'].out_pin == 'QN': invert = True
    else: invert = False

    if inputs['I1'].node == 'one':
        # Input is connected to 1.
        if invert:
            # Return a zero.
            return (~false | p['node_name']) & (false | ~p['node_name'])
        else:
            # Return a one.
            return (~true | p['node_name']) & (true | ~p['node_name'])
    else:
        # Input ist connected to 0.
        if invert:
            # Return a one.
            return (~true | p['node_name']) & (true | ~p['node_name'])
        else:
            # Return a zero.
            return (~false | p['node_name']) & (false | ~p['node_name'])


def in_node(inputs: dict, graph: nx.DiGraph) -> Symbol:
    ''' In node.

    Args:
        inputs: {'I1', 'node_name'}.
        graph: The networkx graph of the circuit.

    Returns:
        ZN = I if invert==false or
        ZN = !I if invert==true
    '''
    p = validate_inputs(inputs, graph, 'in_node')
    if inputs['node_name'].out_pin == 'QN': invert = True
    else: invert = False

    if invert: return (~p['I1'] | ~p['node_name']) & (p['I1'] | p['node_name'])
    else: return (~p['I1'] | p['node_name']) & (p['I1'] | ~p['node_name'])


def out_node(inputs: dict, graph: nx.DiGraph) -> Symbol:
    ''' Out node.

    Args:
        inputs: {'D', 'node_name'}.
        graph: The networkx graph of the circuit.

    Returns:
        ZN = D.
    '''
    p = validate_inputs(inputs, graph, 'out_node')
    return (~p['D'] | p['node_name']) & (p['D'] | ~p['node_name'])


def output(inputs: dict, graph: nx.DiGraph) -> Symbol:
    ''' Out node.

    Args:
        inputs: {'D', 'node_name'}.
        graph: The networkx graph of the circuit.

    Returns:
        ZN = I.
    '''
    p = validate_inputs(inputs, graph, 'output')
    return (~p['I1'] | p['node_name']) & (p['I1'] | ~p['node_name'])

def register(inputs: dict, graph: nx.DiGraph) -> Symbol:
    ''' A simplified register.

    Args:
        inputs: {'D', 'node_name'}.
        graph: The networkx graph of the circuit.

    Returns:
        Q = 'D'
        QN = '!D'.
    '''
    if graph.in_edges(inputs['node_name'].node):
        p = validate_inputs(inputs, graph, 'register')
        return ((~p['D'] | Symbol(inputs['node_name'].node + '_q')) &
                (p['D'] | ~Symbol(inputs['node_name'].node + '_q'))), (
                    (~p['D'] | ~Symbol(inputs['node_name'].node + '_qn')) &
                    (p['D'] | Symbol(inputs['node_name'].node + '_qn')))
    else:
        # Register with no inputs is ignored.
        return true
"""

CELL_FUNCTION = """
def {name}(inputs: dict, graph: nx.DiGraph) -> Symbol:
    ''' {name} gate.

    Args:
        inputs: {inputs}
        graph: The networkx graph of the circuit.
    Returns:
        {output} = {function}
    '''
    p = validate_inputs(inputs, graph, '{name}')
    return ({function_cnf})\n
"""

""" Gate In Type format string.

Contains the mapping cell_name to input_key.
E.g., the cell "OAI21_X1" with the inputs "A", "B1", "B2" is transformed to:
"OAI21_X1": "A1B2"
"""
CELL_IN_TYPE = """
gate_in_type = {{
{gate_in}
  'register': 'D1',
  'out_node': 'D1',
  'xnor': 'I2',
  'xor': 'I2',
  'input_formula': 'I1',
  'in_node': 'I1',
  'output': 'I1'
}}
"""

""" In Type Pins format string.

Contains the mapping input_key to inputs.
E.g., the cell "OAI21_X1" with the inputs "A", "B1", "B2" is transformed to:
"A1B2": "A", "B1", "B2"
"""
CELL_IN_TYPE_PINS = """
in_type_pins = {{
{cell_in}
}}
"""

""" The cell mapping consists the mapping from the cell name string to
    the corresponding cell function.
"""
CELL_MAPPING = """
cell_mapping = {{
{cell_mapping}
  'DFFS_X1_Q': register,
  'DFFS_X1_QN': register,
  'DFFR_X1_Q': register,
  'DFFR_X1_QN': register
}}
"""

""" Pin mapping template.

This dict contains the mapping from one input_key to another input_key.
E.g., the input_key with the inputs "A1, A2, B1, B2" is mapped to
A1B1C2 with the inputs "A, B, C1, C2". This mapping is needed for the fault
injection, where one cell is replaced with another.

Note that this dict needs to be manually modified by the user when switchting
to another cell library. This mapping is only valid for the NANGATE45 cell lib.

"""
pin_mapping = """
# The mapping from one input pin type to another used by the injector.
pin_mapping = {
    'A2B2': {
        'A1B1C2': {
            'A1': 'A',
            'A2': 'B',
            'B1': 'C1',
            'B2': 'C2'
        }
    },
    'A2B2': {
        'A4': {
            'A1': 'A1',
            'A2': 'A2',
            'B1': 'A3',
            'B2': 'A4'
        }
    },
    'A1B1C2': {
        'A2B2': {
            'A': 'A1',
            'B': 'A2',
            'C1': 'B1',
            'C2': 'B2'
        }
    },
    'A1B1C2': {
        'A4': {
            'A': 'A1',
            'B': 'A2',
            'C1': 'A3',
            'C2': 'A4'
        }
    },
    'A4': {
        'A2B2': {
            'A1': 'A1',
            'A2': 'A2',
            'A3': 'B1',
            'A4': 'B2'
        }
    },
    'A4': {
        'A1B1C2': {
            'A1': 'A',
            'A2': 'B',
            'A3': 'C1',
            'A4': 'C2'
        }
    },
    'A3': {
        'A1B2': {
            'A1': 'A',
            'A2': 'B1',
            'A3': 'B2'
        }
    },
    'A3': {
        'A1B1S1': {
            'A1': 'A',
            'A2': 'B',
            'A3': 'S'
        }
    },
    'A1B2': {
        'A3': {
            'A': 'A1',
            'B1': 'A2',
            'B2': 'A3'
        }
    },
    'A1B2': {
        'A1B1S1': {
            'A': 'A',
            'B1': 'B',
            'B2': 'S'
        }
    },
    'A1B1S1': {
        'A3': {
            'A': 'A1',
            'B': 'A2',
            'S': 'A3'
        }
    },
    'A1B1S1': {
        'A1B2': {
            'A': 'A',
            'B': 'B1',
            'S': 'B2'
        }
    },
    'A2': {
        'A1B1': {
            'A1': 'A',
            'A2': 'B'
        }
    },
    'A1B1': {
        'A2': {
            'A': 'A1',
            'B': 'A2'
        }
    }
}
"""
